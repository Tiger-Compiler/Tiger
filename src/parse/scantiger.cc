// src/parse/scantiger.cc generated by reflex 3.2.12 from src/parse/scantiger.ll

#define REFLEX_VERSION "3.2.12"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#undef REFLEX_OPTION_YYLTYPE
#undef REFLEX_OPTION_YYSTYPE
#undef REFLEX_OPTION_bison_cc
#undef REFLEX_OPTION_bison_cc_namespace
#undef REFLEX_OPTION_bison_cc_parser
#undef REFLEX_OPTION_bison_complete
#undef REFLEX_OPTION_bison_locations
#undef REFLEX_OPTION_debug
#undef REFLEX_OPTION_flex
#undef REFLEX_OPTION_header_file
#undef REFLEX_OPTION_lex
#undef REFLEX_OPTION_lexer
#undef REFLEX_OPTION_namespace
#undef REFLEX_OPTION_noyywrap
#undef REFLEX_OPTION_outfile
#undef REFLEX_OPTION_params
#undef REFLEX_OPTION_prefix
#undef REFLEX_OPTION_token_eof
#undef REFLEX_OPTION_token_type

#define REFLEX_OPTION_YYLTYPE             parse::location
#define REFLEX_OPTION_YYSTYPE             parse::parser::semantic_type
#define REFLEX_OPTION_bison_cc            true
#define REFLEX_OPTION_bison_cc_namespace  parse
#define REFLEX_OPTION_bison_cc_parser     parser
#define REFLEX_OPTION_bison_complete      true
#define REFLEX_OPTION_bison_locations     true
#define REFLEX_OPTION_debug               true
#define REFLEX_OPTION_flex                true
#define REFLEX_OPTION_header_file         "src/parse/scantiger.hh"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_namespace           parse
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "src/parse/scantiger.cc"
#define REFLEX_OPTION_params              ::parse::TigerDriver& td
#define REFLEX_OPTION_prefix              yy
#define REFLEX_OPTION_token_eof           parse::parser::symbol_type(0, location())
#define REFLEX_OPTION_token_type          parse::parser::symbol_type

// --debug option enables ASSERT:
#define ASSERT(c) assert(c)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 17 "src/parse/scantiger.ll"


#define YY_EXTERN_C extern "C" // For linkage rule

#include <cerrno>
#include <climits>
#include <regex>
#include <string>

#include <boost/lexical_cast.hpp>

#include <misc/contract.hh>
  // Using misc::escape is very useful to quote non printable characters.
  // For instance
  //
  //    std::cerr << misc::escape('\n') << '\n';
  //
  // reports about `\n' instead of an actual new-line character.
#include <misc/escape.hh>
#include <misc/symbol.hh>
#include <parse/parsetiger.hh>
#include <parse/tiger-driver.hh>

  // FIXME: Some code was deleted here (Define YY_USER_ACTION to update locations).
  #define YY_USER_ACTION                \
      td.location_.columns(size());



#define TOKEN(Type)                             \
  parser::make_ ## Type(td.location_)

#define TOKEN_VAL(Type, Value)                  \
  parser::make_ ## Type(Value, td.location_)

# define CHECK_EXTENSION()                              \
  do {                                                  \
    if (!td.enable_extensions_p_)                       \
      td.error_ << misc::error::error_type::scan        \
                << td.location_                         \
                << ": invalid identifier: `"            \
                << misc::escape(text()) << "'\n";       \
  } while (false)




////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE DEFINITIONS                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define INITIAL (0)
#define SC_COMMENT (1)
#define SC_STRING (2)
#define YY_NUM_RULES (6)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE ABSTRACT LEXER CLASS                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/flexlexer.h>

namespace parse {

typedef reflex::FlexLexer<reflex::Matcher> FlexLexer;

} // namespace parse

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace parse {

class Lexer : public FlexLexer {
#line 75 "src/parse/scantiger.ll"

  // FIXME: Some code was deleted here (Local variables).
  std::string current_str = "";

 public:
  Lexer(
      // a persistent source of input, empty by default
      const reflex::Input& input = reflex::Input(),
      // optional output stream, NULL means std::cout by default
      std::ostream *os = NULL)
    :
      FlexLexer(input, os)
  {
    set_debug(true);
  }
  std::string filename;
  // bison-complete bison-locations: location() returns lexeme location
  virtual parse::location location(void)
  {
    parse::location yylloc;
    yylloc.begin.filename = &filename;
    yylloc.begin.line = static_cast<unsigned int>(matcher().lineno());
    yylloc.begin.column = static_cast<unsigned int>(matcher().columno());
    yylloc.end.filename = &filename;
    yylloc.end.line = static_cast<unsigned int>(matcher().lineno_end());
    yylloc.end.column = static_cast<unsigned int>(matcher().columno_end());
    return yylloc;
  }
  virtual parse::parser::symbol_type yylex(void)
  {
    LexerError("Lexer::yylex invoked but %option lex=lex is used");
    yyterminate();
  }
  // the flex bison-complete lexer function defined by SECTION 2
  virtual parse::parser::symbol_type lex(::parse::TigerDriver& td);
};

} // namespace parse

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "src/parse/scantiger.ll"
/* -*- C++ -*- */
// %option defines the parameters with which the reflex will be launched
#line 4 "src/parse/scantiger.ll"
// To enable compatibility with bison
#line 11 "src/parse/scantiger.ll"
// Add a param of function lex() generate in Lexer class
#line 14 "src/parse/scantiger.ll"
// Name of the class generate by reflex
#line 66 "src/parse/scantiger.ll"
/* Abbreviations.  */
#line 73 "src/parse/scantiger.ll"
/* DONE: Some code was deleted here. */


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON C++                                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

parse::parser::symbol_type parse::Lexer::lex(::parse::TigerDriver& td)
{
  static const char *REGEX_INITIAL = "(?m)((?:(?:\\n\\r|\\r\\n|\\r|\\n)))|((?:(?:\\t|[\\x20])+))|((?:(?:\\+|-)?[0-9]+))|((?:\\Q\"\\E))";
  static const reflex::Pattern PATTERN_INITIAL(REGEX_INITIAL);
  static const char *REGEX_SC_COMMENT = "(?m)";
  static const reflex::Pattern PATTERN_SC_COMMENT(REGEX_SC_COMMENT);
  static const char *REGEX_SC_STRING = "(?m)((?:[A-Za-z]+))|((?:\\Q\"\\E))";
  static const reflex::Pattern PATTERN_SC_STRING(REGEX_SC_STRING);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
    YY_USER_INIT
  }
  switch (start())
  {
    case INITIAL:
#line 82 "src/parse/scantiger.ll"
/* The rules.  */
    break;
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF\033[0m start(" << start() << ")\n";
              yyterminate();
            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31mdefault rule\033[0m\n";
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule src/parse/scantiger.ll:82: {eol} :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:82\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 82 "src/parse/scantiger.ll"
td.location_.lines();
            YY_BREAK
          case 2: // rule src/parse/scantiger.ll:83: {blank} :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:83\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 83 "src/parse/scantiger.ll"
            YY_BREAK
          case 3: // rule src/parse/scantiger.ll:84: {int} :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:84\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 84 "src/parse/scantiger.ll"
{
                // DONE: Some code was deleted here (Decode, and check the value).
                int val = std::atoi(text());

                if (val == -1 && (chr() != '-' || text()[1] != '1' || size() != 2))
                    throw std::runtime_error("This is not a int");

                return TOKEN_VAL(INT, val);
              }
  /* DONE: Some code was deleted here. */
            YY_BREAK
          case 4: // rule src/parse/scantiger.ll:94: "\"" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:94\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 94 "src/parse/scantiger.ll"
start(SC_STRING);


            YY_BREAK
        }
        break;
      case SC_COMMENT:
        matcher().pattern(PATTERN_SC_COMMENT);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF\033[0m start(" << start() << ")\n";
              yyterminate();
            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31mdefault rule\033[0m\n";
              output(matcher().input());
            }
            YY_BREAK
        }
        break;
      case SC_STRING:
        matcher().pattern(PATTERN_SC_STRING);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF\033[0m start(" << start() << ")\n";
              yyterminate();
            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31mdefault rule\033[0m\n";
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule src/parse/scantiger.ll:98: {string} :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:98\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 98 "src/parse/scantiger.ll"
current_str.append(text());
            YY_BREAK
          case 2: // rule src/parse/scantiger.ll:99: "\"" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:99\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 99 "src/parse/scantiger.ll"
{
                    std::string tmp = current_str;
                    current_str = "";
                    start(INITIAL);
                    return TOKEN_VAL(STRING, tmp);
                }
            YY_BREAK
        }
        break;
      default:
        start(0);
    }
  }
}
